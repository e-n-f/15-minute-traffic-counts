#!/usr/bin/perl

use POSIX;

$pi = 4 * atan2(1, 1);

open(IN, "counts-minneapolis.csv");
while (<IN>) {
	chomp;
	($id, $name, $id2, $date, $time, @rest) = split(/,/);
	$walk = $rest[12] + $rest[13] + $rest[14] + $rest[15];

	$walk{"$name $date"}{$time} = $walk;
}

for $where (keys(%walk)) {
	%times = %{$walk{$where}};
	@times = keys(%times);
	$times = $#times + 1;

	next if $times != 96;

	for $t (@times) {
		$daytotal{$where} += $times{$t};
		$total{$t} += $times{$t};
		$total += $times{$t};
	}
}

for $where (keys(%daytotal)) {
	%times = %{$walk{$where}};
	@times = keys(%times);

	next if $daytotal{$where} == 0;

	if ($daytotal{$where} > $daytotal{$most}) {
		$most = $where;
	}

	for $t (@times) {
		if ($times{$t} != 0) {
			push @{$timelist{$t}}, ($daytotal{$where} / $times{$t});
		}
	}
}

for $t (sort(keys(%total))) {
	@l = sort { $a <=> $b } @{$timelist{$t}};

	$sum = 0;
	$count = 0;
	for ($i = $#l * 0; $i <= $#l * 1; $i++) {
		$sum += log($l[$i]);
		$count++;
	}
	$geom = exp($sum / $count);
	$scale{$t} = $geom;
	$median{$t} = $l[$#l / 2];
}

sub walkscale {
	my $x = $_[0];

	my $a               = 0.952203;
	my $u               = 15.1218;
	my $o               = 4.43061;
	my $a1              = -0.0507668;
	my $u1              = 14.3222;
	my $o1              = 0.982951;
	my $a2              = 0.0958098;
	my $u2              = 7.88115;
	my $o2              = 1.17773;

	return (
		$a  * exp(- pow($x - $u,  2) / (2 * $o  * $o ))/($o  * sqrt(2 * $pi)) +
		$a1 * exp(- pow($x - $u1, 2) / (2 * $o1 * $o1))/($o1 * sqrt(2 * $pi)) +
		$a2 * exp(- pow($x - $u2, 2) / (2 * $o2 * $o2))/($o2 * sqrt(2 * $pi))
	) / 4;
}

%scale = ();
for ($h = 0; $h < 24; $h += .25) {
	$h1 = int($h);
	$m1 = ($h - int($h)) * 60;

	$h2 = int($h + .25);
	$m2 = ($h + .25 - int($h + .25)) * 60;

	$key = sprintf("%02d:%02d-%02d:%02d", $h1, $m1, $h2, $m2);
	$x = $h + $m / 60;

	if ($x < 4) { $x += 24; }

	$scale{$key} = 1 / (&walkscale($x) + &walkscale($x - 24) + &walkscale($x + 24));
}

@daytotal = sort { $daytotal{$b} <=> $daytotal{$a} } keys(%daytotal);
@daytimes = sort(keys(%total));

for ($start = 0; $start <= $#daytimes; $start++) {
	print "$daytimes[$start] $scale{$daytimes[$start]} $median{$daytimes[$start]} ";

	#for $duration (0) {
	for ($duration = 0; $duration <= 8 * 4; $duration++) {
	#for ($duration = 0; $duration <= $#daytimes; $duration++) {
		@deviations = ();

		for $d (@daytotal) {
			next if ($daytotal{$d} == 0);

			$sum = 0;
			$count = 0;

			for ($tt = $start; $tt < $start + $duration + 1; $tt++) {
				$t = $daytimes[$tt % ($#daytimes + 1)];

				if ($walk{$d}{$t} != 0) {
					$sum += log($walk{$d}{$t} * $scale{$t});
					$count += 1;
				}

				if ($scale{$t} == 0) {
					die "no scaling for $t\n";
				}
			}

			if ($count != 0 && $sum != 0) {
				push @deviations, log((exp($sum / $count)) / $daytotal{$d});
				#print "$deviations[$#deviations] ";
				#printf("%s %.6f %f %f\n", $daytimes[$start], (exp($sum / $count)) / $daytotal{$d}, (exp($sum / $count)), $daytotal{$d});

				# printf("%.6f %d\n", $sum / $count / $daytotal{$d}, $daytotal{$d});
			}
		}

		if ($#deviations < 0) {
			print "-- ";
			next;
		}

		$sum = 0;
		$count = 0;
		for $d (@deviations) {
			$sum += $d;
			$count++;
		}
		$mean = $sum / $count;
		$mean = 0;  # because we want to compare to correctness, even if they are all skewed one way or the other

		$variance = 0;
		for $d (@deviations) {
			$variance += ($d - $mean) * ($d - $mean);
		}
		#print "mean $mean variance $variance\n";
		$variance /= $count;
		$stddev = sqrt($variance);
		printf("%.3f ", exp($stddev));
	}
	print "\n";
}
